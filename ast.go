// Code generated by yy. DO NOT EDIT.

// Copyright 2017 The WL Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package wl

import (
	"go/token"
)

// Expr represents data reduced by productions:
//
//	Expr:
//	        "floating point literal"
//	|       "identifier"                             // Case 1
//	|       "identifier" "::" Tag "::" Tag '=' Expr  // Case 2
//	|       "identifier" "::" Tag '=' Expr           // Case 3
//	|       "identifier" '[' ExprList ']'            // Case 4
//	|       "integer literal"                        // Case 5
//	|       "pattern"                                // Case 6
//	|       "string literal"                         // Case 7
//	|       '(' Expr ')'                             // Case 8
//	|       '-' Expr                                 // Case 9
//	|       '{' '}'                                  // Case 10
//	|       '{' ExprList '}'                         // Case 11
//	|       Expr "=!=" Expr                          // Case 12
//	|       Expr "&&" Expr                           // Case 13
//	|       Expr "/;" Expr                           // Case 14
//	|       Expr ":=" Expr                           // Case 15
//	|       Expr '!'                                 // Case 16
//	|       Expr '*' Expr                            // Case 17
//	|       Expr '+' Expr                            // Case 18
//	|       Expr '/' Expr                            // Case 19
//	|       Expr '=' Expr                            // Case 20
type Expr struct {
	Case     int
	Expr     *Expr
	Expr2    *Expr
	ExprList *ExprList
	Tag      *Tag
	Tag2     *Tag
	Token    Token
	Token2   Token
	Token3   Token
	Token4   Token
}

func (n *Expr) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Expr) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Expr) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 12, 13, 14, 15, 16, 17, 18, 19, 20:
		return n.Expr.Pos()
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ExprList represents data reduced by productions:
//
//	ExprList:
//	        Expr
//	|       ExprList ',' Expr  // Case 1
type ExprList struct {
	Case     int
	Expr     *Expr
	ExprList *ExprList
	Token    Token
}

func (n *ExprList) reverse() *ExprList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ExprList
	for nb != nil {
		nc := nb.ExprList
		nb.ExprList = na
		na = nb
		nb = nc
	}
	n.ExprList = nil
	return na
}

func (n *ExprList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ExprList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExprList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Expr.Pos()
	case 1:
		return n.ExprList.Pos()
	default:
		panic("internal error")
	}
}

// Start represents data reduced by productions:
//
//	Start:
//	        Expr
//	|       Expr ';'  // Case 1
type Start struct {
	Case  int
	Expr  *Expr
	Token Token
}

func (n *Start) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Start) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Start) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Expr.Pos()
}

// Tag represents data reduced by productions:
//
//	Tag:
//	        "identifier"
//	|       "string literal"  // Case 1
type Tag struct {
	Case  int
	Token Token
}

func (n *Tag) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Tag) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Tag) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}
