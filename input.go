// Code generated by golex. DO NOT EDIT.

// Copyright 2017 The WL Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package wl

import (
	"strconv"
)

func (lx *lexer) ReadRune() (r rune, sz int, err error) {
	c := lx.enter()

yystate0:

	goto yystart1

	goto yystate0 // silence unused label error
	goto yystate1 // silence unused label error
yystate1:
	c = lx.next()
yystart1:
	switch {
	default:
		goto yyabort
	case c == '\\':
		goto yystate2
	}

yystate2:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c == ' ':
		goto yystate3
	case c == '"':
		goto yystate4
	case c == '.':
		goto yystate5
	case c == ':':
		goto yystate11
	case c == '[':
		goto yystate16
	case c == '\\':
		goto yystate19
	case c == 'b':
		goto yystate20
	case c == 'f':
		goto yystate21
	case c == 'n':
		goto yystate22
	case c == 'r':
		goto yystate23
	case c == 't':
		goto yystate24
	case c >= '0' && c <= '9':
		goto yystate8
	}

yystate3:
	c = lx.next()
	goto yyrule2

yystate4:
	c = lx.next()
	goto yyrule3

yystate5:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate6
	}

yystate6:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate7
	}

yystate7:
	c = lx.next()
	goto yyrule11

yystate8:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9':
		goto yystate9
	}

yystate9:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9':
		goto yystate10
	}

yystate10:
	c = lx.next()
	goto yyrule10

yystate11:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate12
	}

yystate12:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate13
	}

yystate13:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate14
	}

yystate14:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f':
		goto yystate15
	}

yystate15:
	c = lx.next()
	goto yyrule12

yystate16:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c >= 'A' && c <= 'Z':
		goto yystate17
	}

yystate17:
	c = lx.next()
	switch {
	default:
		goto yyabort
	case c == ']':
		goto yystate18
	case c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z':
		goto yystate17
	}

yystate18:
	c = lx.next()
	goto yyrule9

yystate19:
	c = lx.next()
	goto yyrule1

yystate20:
	c = lx.next()
	goto yyrule4

yystate21:
	c = lx.next()
	goto yyrule7

yystate22:
	c = lx.next()
	goto yyrule6

yystate23:
	c = lx.next()
	goto yyrule8

yystate24:
	c = lx.next()
	goto yyrule5

yyrule1: // \\\\
	{
		return '\\', 2, lx.rerr
	}
yyrule2: // \\\x20
	{
		return ' ', 2, lx.rerr
	}
yyrule3: // \\\"
	{
		return '"', 2, lx.rerr
	}
yyrule4: // \\b
	{
		return '\b', 2, lx.rerr
	}
yyrule5: // \\t
	{
		return '\t', 2, lx.rerr
	}
yyrule6: // \\n
	{
		return '\n', 2, lx.rerr
	}
yyrule7: // \\f
	{
		return '\f', 2, lx.rerr
	}
yyrule8: // \\r
	{
		return '\r', 2, lx.rerr
	}
yyrule9: // "\["[A-Z][A-Za-z]*"]"
	{

		s := lx.token()
		return lx.named(s[2 : len(s)-2])
	}
yyrule10: // \\{d}{d}{d}
	{

		n, err := strconv.ParseInt(lx.token()[1:4], 8, 8)
		if err != nil {
			return 0, 0, err
		}
		return rune(n), 4, lx.rerr
	}
yyrule11: // \\\.{h}{h}
	{

		n, err := strconv.ParseInt(lx.token()[2:4], 16, 8)
		if err != nil {
			return 0, 0, err
		}
		return rune(n), 4, lx.rerr
	}
yyrule12: // \\\:{h}{h}{h}{h}
	{

		n, err := strconv.ParseInt(lx.token()[2:6], 16, 16)
		if err != nil {
			lx.errPos(lx.First.Pos(), err.Error())
			return 0, 0, err
		}
		return rune(n), 6, lx.rerr
	}
	panic("unreachable")

	goto yyabort // silence unused label error

yyabort: // no lexem recognized
	lx.c = -1
	return rune(c), lx.sz, lx.rerr
}
